/**
 * split messages generated from hourly data file to send over iridium network
 * tests for adding message splitting into library
 * 
 * Author: Rachel Pagdin
 * August 1, 2024
 */

#define BATT_MULT 100
#define MEM_MULT 0.01
#define IridiumSerial Serial1

#include <SD.h>
#include <SPI.h>
#include <CSV_Parser.h>
#include <IridiumSBD.h>

String csv_setting = "sfffff";          // this is auto-generated by private helper in library
const int dataInMessage = 7;            // number of readings in a single message
const int chipSelect = 4;               // SD card - handled by library
const int IridSlpPin = 13;              // handled by library

// from Hydros (for sample hourly data file)
String header = "datetime,batt_v,memory,water_level_mm,water_temp_c,water_ec_dcm";      // header for CSV file
const byte myParams = 3;        // number of sampled parameters 
float myMultipliers[myParams] = {1, 10, 1};         // multipliers for parameters (in order) to remove decimals for messages
String myLetters = "ABC";         // letters for start of message, correspond to sampled parameters

IridiumSBD modem(IridiumSerial);

void setup(){
    delay(50);
    Serial.begin(115200);
    delay(100);
    
}

void loop(){
    String msg = prep_msg();
    Serial.println(msg);

    int err = send_msg(msg);
    Serial.println(err);

    delay(10000);

    
}

String prep_msg(){
    // start the SD card 
    SD.begin(chipSelect);

    // read the hourly data file and determine number of rows
    char buf[csv_setting.length()+1];
    csv_setting.toCharArray(buf, csv_setting.length()+1);
    CSV_Parser cp(buf, true, ',');      
    cp.readSDfile("/HOURLY.csv");       
    int num_rows = cp.getRowsCount(); 

    String datastring_msg = "";
    datastring_msg.reserve(25*num_rows);
    int rowsToSend = num_rows;
    int messages = 0;
    int last_row;

    char **out_datetimes;
    float *floatOut;

    while(rowsToSend > 0){
        if((rowsToSend-dataInMessage) >= 0) last_row = dataInMessage*(messages+1) - 1;
        else last_row = num_rows - 1;

        datastring_msg += myLetters;
        datastring_msg += ":";

        int column = 0;        // position of the header we're on

        // timestamp of first sample to be included in this message
        out_datetimes = (char **)cp[column];       // get list of datetimes 
        datastring_msg += String(out_datetimes[dataInMessage*messages]).substring(2,4); 
        datastring_msg += String(out_datetimes[dataInMessage*messages]).substring(5,7);
        datastring_msg += String(out_datetimes[dataInMessage*messages]).substring(8,10);
        datastring_msg += String(out_datetimes[dataInMessage*messages]).substring(11,13);
        datastring_msg += ":";
        column++;       // move on to battery
        // battery, memory of last sample to be included in this message
        floatOut = (float *)cp[column];
        datastring_msg += String(round(floatOut[last_row] * BATT_MULT));
        datastring_msg += ":";
        column++;       // move on to memory
        floatOut = (float *)cp[column];
        datastring_msg += String(round(floatOut[last_row] * MEM_MULT)); 
        datastring_msg += ":";

        for(int row = dataInMessage*messages; row <= last_row; row++){     //iterate through the rows to be included in current message
            column = 3;     // start at first column of sampled data

            while(column < myParams+3){
                if(myMultipliers[column-3] != 0){       // actually want to send this parameter
                    floatOut = (float *)cp[column];
                    datastring_msg += String(round(floatOut[row] * myMultipliers[column-3]));
                    datastring_msg += ",";         // add commas between
                }
                column++;       // go to the next column
            }
            datastring_msg.setCharAt(datastring_msg.length()-1, ':');       // set the last character
        }
        
        rowsToSend = rowsToSend - dataInMessage;
        if(rowsToSend > 0){
            datastring_msg += "!";          // separator between messages
        }
        messages++;
    }

    return datastring_msg;

}

int send_msg(String msg){
    int messages = 0, send_fail = 0, irid_err;
    bool failed = false;

    digitalWrite(IridSlpPin, HIGH);     // wake up the modem
    delay(2000);        // wait for RockBlock to power on

    IridiumSerial.begin(19200);
    modem.setPowerProfile(IridiumSBD::USB_POWER_PROFILE);

    int irid_err = modem.begin();        // start up the modem
    if (irid_err == ISBD_IS_ASLEEP){
        irid_err = modem.begin();    // try to start up again
    }

    char buf[msg.length()+1];
    msg.toCharArray(buf, msg.length()+1);

    char* tok = strtok(buf, "!");

    while(tok != NULL){
        messages++;
        Serial.println(tok);
        
        //send message 
        irid_err = modem.sendSBDText(buf);
        if(irid_err != ISBD_SUCCESS){       // if unsuccessful, try again
            irid_err = modem.begin();
            irid_err = modem.sendSBDText(buf);
        }
        if(irid_err != ISBD_SUCCESS){       // send was unsuccessful after two tries
            send_fail++;        
        }
        if((messages == 1) && (send_fail == 1)){        // first send unsuccessful -- probably no signal
            failed = true;
            break;
        }

        tok = strtok(NULL, "!");
    }
    failed = (messages == send_fail);

    // sync time
    if(rtc.now().hour() == 12 && rtc.now().day() % 5 == 0){
        // sync_clock();        // handled by library
    }

    digitalWrite(IridSlpPin, LOW);      // put the modem back to sleep

    if(failed){         // all sends unsuccessful
        return ISBD_CANCELLED;      
    } else {
        // SD.remove("/HOURLY.csv"); 
        return ISBD_SUCCESS;      // at least one message was sent -- remove others to avoid duplicates
    }
}
